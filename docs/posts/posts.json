[
  {
    "path": "posts/2021-10-13-multi-modal/",
    "title": "Working with Multi-modal data",
    "description": "A short tutorial describing a basic CITE-seq analysis workflow.",
    "author": [
      {
        "name": "Kent Riemondy",
        "url": "https://github.com/kriemo"
      },
      {
        "name": "Ryan Sheridan",
        "url": "https://github.com/sheridar"
      }
    ],
    "date": "2021-10-13",
    "categories": [],
    "contents": "\nExperimental design\nCITE-seq enables detection of cell surface proteins AND gene expression\n\nCITE-seq reagents\nBiolegend is the main company selling CITE-seq and cell hashing antibodies (TotalSeq). Biolegend reagents are divided into three product lines:\nTotalSeq-A: 3’ gene expression, v2 and v3 chemistry\nTotalSeq-B: 3’ gene expression, v3 chemistry\nTotalSeq-C: 5’ gene expression and V(D)J\n\nCell hashing reagents\nCell hashing allows for sample multiplexing and “super-loaded” runs with >10,000 captured cells. Super-loading results in higher doublet rates (~10% for 10,000 captured cells), but these doublets can be removed by identifying cell barcodes that are associated with multiple hashtag oligos.\n\nBiolegend cell hashing reagents for human cells include a mix of two antibodies that recognize CD298 and β2 microglobulin. Mouse hashing antibodies recognize CD45 and H-2 MHC class I.\nTotalSeq-A reagents use a different PCR handle for CITE-seq and cell hashing antibodies. This means two separate libraries have to be prepared. To ensure that the correct libraries are created, it is import to tell the sequencing core which types of antibodies were included in the experiment.\nTotalSeq-C reagents use the same PCR handle for CITE-seq and cell hashing antibodies, which means that only a single library will be prepared. However, to ensure that the correct libraries are created the core should be notified of all reagents used for the experiment.\nMULTI-seq uses lipid- and cholesterol-modified oligonucleotides.\n\nCreating a Seurat object with multiple assays\nLoading counts matrices\nThe Read10X function can be used with the output directory generated by Cell Ranger. However, public datasets can be formatted in many different ways, so it is very useful to become familar with converting between formats. Our UMI count data is stored as comma-separated files, which we can load as data.frames and then convert to sparse matrices.\nOur data today will be a collection of 4 PBMC samples that have each been “hashed” with different cell-hashtags, stained with 8 different CITE-seq antibodies, then combined and captured on the 10x platform in 1 sample.\nWe have three files that we will work with:\nCITEseq_cDNA.csv.gz: UMI count gene expression data\nCITEseq_ADT.csv.gz: Antibody count data\nCITEseq_HTO.csv.gz: Hashtag count data\n\n\n# Data URL\ndata_url <- \"https://scrnaseq-workshop.s3-us-west-2.amazonaws.com\"\n\n# Function to import counts\nimport_counts <- function(file_name, file_url = data_url) {\n  mtx <- file.path(file_url, file_name) %>%\n    read_csv() %>%\n    column_to_rownames(colnames(.[, 1])) %>%\n    as.sparse()\n\n  mtx\n}\n\n# Import gene expression matrix\nrna_mtx <- import_counts(\"CITEseq_cDNA.csv.gz\")\n\n# Import CITE-seq matrix\nadt_mtx <- import_counts(\"CITEseq_ADT.csv.gz\")\n\nrownames(adt_mtx) <- str_c(\"adt-\", rownames(adt_mtx))\nadt_mtx[, 1:10]\n\n\n#> 8 x 10 sparse Matrix of class \"dgCMatrix\"\n#>                                               \n#> adt-CD14   11   2  14   1   .   1   1  . .   1\n#> adt-CD19    9   . 165 295   .   3   6  4 2   1\n#> adt-CD3     .  19  79   2   3   6   9  3 3   4\n#> adt-CD4    69 360 293   7 159 321   1  7 7   4\n#> adt-CD45    .   .   3   4   .   1   .  . 1   .\n#> adt-CD45RA 25   3 246  16   8   5  18  6 4   9\n#> adt-CD45RO  6   4 108   6   .   2   1  2 1   3\n#> adt-CD8     7   .  36   6   .   . 473 21 7 197\n\n# Import HTO matrix\nhto_mtx <- import_counts(\"CITEseq_HTO.csv.gz\")\n\nhto_mtx[, 1:10]\n\n\n#> 4 x 10 sparse Matrix of class \"dgCMatrix\"\n#>                                             \n#> HTO28 351   .   .  .   2 161   .   .   .   .\n#> HTO29   6   2   3  1   1   2   2 107   2   .\n#> HTO30   . 131 177 60   .   .   .   . 239 155\n#> HTO44   1   .   .  . 122   . 172   .   1   .\n\nCreating a Seurat object\nWhen adding multiple assays to a Seurat object, we first must identify cell barcodes that are present in all of the datasets. If one of the assays has a different number of cell barcodes Seurat will throw an error.\n\n\n# Get list of common cell barcodes\nrna_bcs <- colnames(rna_mtx)\nadt_bcs <- colnames(adt_mtx)\nhto_bcs <- colnames(hto_mtx)\n\nmerged_bcs <- rna_bcs %>%\n  intersect(adt_bcs) %>%\n  intersect(hto_bcs)\n\n# Create Seurat object\nsobj <-  CreateSeuratObject(\n  counts    = rna_mtx[, merged_bcs], \n  min.cells = 5\n)\n\n# Add CITE-seq and cell hashing data to Seurat object\nsobj[[\"ADT\"]] <- CreateAssayObject(adt_mtx[, merged_bcs])\n\nsobj[[\"HTO\"]] <- CreateAssayObject(hto_mtx[, merged_bcs])\n  \nsobj\n\n\n#> An object of class Seurat \n#> 15032 features across 4292 samples within 3 assays \n#> Active assay: RNA (15020 features, 0 variable features)\n#>  2 other assays present: ADT, HTO\n\n\nDemultiplexing hashed samples\nWe will first use the cell hashing data to assign cells to their sample of origin. This is referred to as demultiplexing as we are using the cell hashing antibody barcodes to assign each cell to a sample.\nNormalizing HTO counts\nTo account for differences in antibody binding efficiency, CITE-seq and cell hashing data can be normalized by performing a centered log-ratio transformation for each individual antibody.\nNote that the best approach for normalizing CITE-seq data has not been settled. For a more detailed discussion, and alternative approaches, see the Normalization chapter from the Orchestrating Single Cell Analysis eBook from Bioconductor.\n\n\n# Normalize HTO counts\nsobj <- sobj %>%\n  NormalizeData(\n    assay = \"HTO\",\n    normalization.method = \"CLR\"\n  )\n\n\n\nSample demultiplexing and identification of doublets\nTo demultiplex hashed samples, the HTODemux function uses the normalized HTO counts for k-medoids clustering. This results in a cluster for each HTO. A background signal is then calculated for each HTO using cells that are not present in the HTO-specific cluster. Outlier cells from this background signal are then classified as being “positive” for the HTO if they are above a cutoff quantile value (~97% of background).\nCells that are positive for multiple HTOs are classified as doublets and cells that are not positive for any HTO are classified as “negative” cells.\nThe HTODemux function automatically adds several columns to the object meta.data:\nHTO_classification: shows positive HTOs that were identified for the cell\nHTO_classification.global: singlet classification (singlet, doublet, negative)\nhash.ID: final HTO assignment including doublet and negative classifications\n\n\n# Demultiplex samples\n# By default HTODemux will look for the \"HTO\" assay\nsobj <- sobj %>%\n  HTODemux(positive.quantile = 0.97)\n\nhead(sobj@meta.data, 2)\n\n\n#>                     orig.ident nCount_RNA nFeature_RNA nCount_ADT\n#> AAACCTGAGACAAAGG SeuratProject       3054         1217        388\n#> AAACCTGAGCTACCGC SeuratProject       2411          989        337\n#>                  nFeature_ADT nCount_HTO nFeature_HTO HTO_maxID\n#> AAACCTGAGACAAAGG            5        358            3     HTO28\n#> AAACCTGAGCTACCGC            8        180            2     HTO30\n#>                  HTO_secondID HTO_margin HTO_classification\n#> AAACCTGAGACAAAGG        HTO29   3.211027              HTO28\n#> AAACCTGAGCTACCGC        HTO29   3.448779              HTO30\n#>                  HTO_classification.global hash.ID\n#> AAACCTGAGACAAAGG                   Singlet   HTO28\n#> AAACCTGAGCTACCGC                   Singlet   HTO30\n\n# Summarize cell classifications\ntable(sobj$HTO_classification.global)\n\n\n#> \n#>  Doublet Negative  Singlet \n#>      386        1     3905\n\n# Create ridge plots showing HTO signal\nsobj %>%\n  RidgePlot(\n    assay    = \"HTO\",\n    features = rownames(hto_mtx),\n    ncol     = 2\n  )\n\n\n\n\nCompare the number of cells with each hash.ID and calculate the doublet rate\n\n\n# Calculate doublet rate\nsobj@meta.data %>%\n  group_by(HTO_classification.global) %>% \n  summarize(\n    n     = n(),\n    fract = n / nrow(.)\n  )\n\n\n#> # A tibble: 3 x 3\n#>   HTO_classification.global     n    fract\n#> * <chr>                     <int>    <dbl>\n#> 1 Doublet                     386 0.0899  \n#> 2 Negative                      1 0.000233\n#> 3 Singlet                    3905 0.910\n\n# Create bar graphs comparing cell count for each sample\ndat <- sobj@meta.data %>%\n  rownames_to_column(\"cell_id\")\n\nbars_1 <- dat %>%\n  ggplot(aes(hash.ID, fill = hash.ID)) +\n  geom_bar() +\n  labs(y = \"cell count\") +\n  theme_minimal() +\n  theme(axis.title.x = element_blank())\n\nbars_2 <- dat %>%\n  ggplot(aes(\"PBMC\", fill = hash.ID)) +\n  geom_bar() +\n  labs(y = \"cell count\") +\n  theme_minimal() +\n  theme(axis.title.x = element_blank())\n\n# Combine plots\nplot_grid(\n  bars_1, bars_2,\n  align       = \"h\",\n  nrow        = 1,\n  rel_widths  = c(1, 0.6)\n)\n\n\n\n\n\nFiltering data and assessing quality\nNow that we have assigned each cell to the appropriate sample we can continue with processing the RNA data in the same manner as before.\nAssessing data quality\n\n\n# Add mitochondrial percentage to meta.data table\nsobj <- sobj %>%\n  PercentageFeatureSet(\n    assay    = \"RNA\",\n    pattern  = \"^MT-\", \n    col.name = \"percent_mito\"\n  )\n\n# Create violin plots for gene expression data\nsobj %>%\n  VlnPlot(\n    features = c(\"nCount_RNA\", \"nFeature_RNA\", \"percent_mito\"), \n    ncol     = 3,\n    pt.size  = 0\n  )\n\n\n\n\n\n\n# Aim to sequence CITE-seq libraries at 2k-5k reads/cell, cell hashing 1k-2k reads/cell\nsobj %>%\n  VlnPlot(\n    features = c(\"nCount_ADT\", \"nCount_HTO\"),\n    ncol     = 2,\n    pt.size  = 0,\n    log      = TRUE\n  )\n\n\n\n\n\n\n# Filter cells based on HTO class, number of genes, and percent mito UMIs\nfilt_so <-  sobj %>%\n  subset(\n    nFeature_RNA > 250 &                    # Remove cells with < 250 detected genes\n    nFeature_RNA < 2500 &                   # Remove cells with > 2500 detected genes (could be doublets)\n    percent_mito < 15 &                     # Remove cells with > 0.15 mito/total reads\n    HTO_classification.global == \"Singlet\"\n  )\n\nfilt_so\n\n\n#> An object of class Seurat \n#> 15032 features across 3686 samples within 3 assays \n#> Active assay: RNA (15020 features, 0 variable features)\n#>  2 other assays present: ADT, HTO\n\n# Rename cell identities with sample names\nfilt_so <- filt_so %>%\n  RenameIdents(\n    \"HTO28\" = \"PBMC-1\",\n    \"HTO29\" = \"PBMC-2\",\n    \"HTO30\" = \"PBMC-3\",\n    \"HTO44\" = \"PBMC-4\"\n  )\n\n# Add sample names to meta.data table\nfilt_so$sample <- Idents(filt_so)\n\nhead(filt_so@meta.data, 2)\n\n\n#>                     orig.ident nCount_RNA nFeature_RNA nCount_ADT\n#> AAACCTGAGACAAAGG SeuratProject       3054         1217        388\n#> AAACCTGAGCTACCGC SeuratProject       2411          989        337\n#>                  nFeature_ADT nCount_HTO nFeature_HTO HTO_maxID\n#> AAACCTGAGACAAAGG            5        358            3     HTO28\n#> AAACCTGAGCTACCGC            8        180            2     HTO30\n#>                  HTO_secondID HTO_margin HTO_classification\n#> AAACCTGAGACAAAGG        HTO29   3.211027              HTO28\n#> AAACCTGAGCTACCGC        HTO29   3.448779              HTO30\n#>                  HTO_classification.global hash.ID percent_mito\n#> AAACCTGAGACAAAGG                   Singlet   HTO28     7.105435\n#> AAACCTGAGCTACCGC                   Singlet   HTO30     9.622563\n#>                  sample\n#> AAACCTGAGACAAAGG PBMC-1\n#> AAACCTGAGCTACCGC PBMC-3\n\n\nProcess gene expression data\nTo review the basic Seurat processing workflow, see if you can complete the following steps for our gene expression data:\nLogNormalize the counts (NormalizeData)\nFind variable features (FindVariableFeatures)\nScale the data (ScaleData)\nPerform PCA (RunPCA)\nCluster the cells (FindNeighbors, FindClusters)\nRun UMAP and plot clusters (RunUMAP)\n\n\n# Write your answer here\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\n\n\n\nClustering cells based on antibody signal\nNormalize CITE-seq counts\nBefore clustering, we first want to normalize our CITE-seq data. Like cell hashing data, CITE-seq counts can be normalized by performing a centered log-ratio transformation.\n\n\n# Normalize CITE-seq data\nfilt_so <-  filt_so %>%\n  NormalizeData(\n    assay                = \"ADT\",\n    normalization.method = \"CLR\",\n    verbose              = FALSE\n  ) %>%  \n  ScaleData(\n    assay   = \"ADT\",\n    verbose = FALSE\n  )\n\n\n\nCluster cells using antibody signal\nSince there are only a few antibodies and not many dimensions, instead of performing PCA we can just use the scaled matrix for clustering directly. In contrast to the gene expression data, we have already done feature selection and dimensionality reduction by choosing (for very practical reasons) to only stain cells with a few antibodies that discriminate cell populations. However, if you stained cells with many (>100s) antibodies, then you may want to select variable antibodies, and use PCA for clustering.\nWe will directly pass the scaled.data matrix from the ADT assay to the FindNeighbors function, which creates a Shared Nearest Neighbor (SNN) graph that is used for clustering.\n\n\n# Cluster cells\nfilt_so <- filt_so %>%\n  FindNeighbors(\n    assay      = \"ADT\",\n    reduction  = NULL,                       # we are not using a reduction\n    dims       = NULL,                       # we do not specify dims\n    features   = rownames(filt_so[[\"ADT\"]])  # specify features to use the scaled data\n  ) %>%\n  FindClusters(\n    resolution = 0.2,\n    graph.name = \"ADT_snn\"\n  )\n\n# For clarity store clusters in meta.data as 'ADT_clusters'\nfilt_so$ADT_clusters <- filt_so$ADT_snn_res.0.2\n\n\n\nRun UMAP using antibody signal\n\n\n# Run UMAP\nfilt_so <- filt_so %>%\n  RunUMAP(\n    assay          = \"ADT\",\n    graph          = \"ADT_snn\",\n    reduction.name = \"adt_umap\",\n    reduction.key  = \"ADTUMAP_\"\n  )\n\n# Plot UMAPs\nfilt_so %>%\n  DimPlot(\n    reduction = \"adt_umap\", \n    group.by  = c(\"sample\", \"ADT_clusters\"),\n    ncol      = 2\n  )\n\n\n\n\nIdentify marker proteins\n\n\n# Identify differentially expressed proteins for each cluster\nADT_markers <- filt_so %>%\n  FindAllMarkers(\n    assay    = \"ADT\",\n    only.pos = TRUE\n  )\n\nADT_markers\n\n\n#>                     p_val avg_log2FC pct.1 pct.2     p_val_adj\n#> adt-CD8      0.000000e+00  2.8218624 1.000 0.936  0.000000e+00\n#> adt-CD4      0.000000e+00  3.7010812 1.000 0.903  0.000000e+00\n#> adt-CD14    3.266554e-144  2.4423565 0.885 0.346 2.613243e-143\n#> adt-CD45    3.678499e-102  1.1732629 0.934 0.612 2.942799e-101\n#> adt-CD45RO  2.822220e-101  2.0012303 0.987 0.865 2.257776e-100\n#> adt-CD19     2.468598e-78  0.5313502 0.993 0.912  1.974879e-77\n#> adt-CD45RA   5.105446e-09  0.6653716 0.987 0.982  4.084357e-08\n#> adt-CD191    1.720165e-81  4.9623991 1.000 0.916  1.376132e-80\n#> adt-CD45RA1  8.828050e-20  0.5971657 0.992 0.982  7.062440e-19\n#> adt-CD45RO1  1.411546e-17  0.7362115 0.984 0.871  1.129237e-16\n#>             cluster       gene\n#> adt-CD8           0    adt-CD8\n#> adt-CD4           1    adt-CD4\n#> adt-CD14          3   adt-CD14\n#> adt-CD45          3   adt-CD45\n#> adt-CD45RO        3 adt-CD45RO\n#> adt-CD19          3   adt-CD19\n#> adt-CD45RA        3 adt-CD45RA\n#> adt-CD191         4   adt-CD19\n#> adt-CD45RA1       4 adt-CD45RA\n#> adt-CD45RO1       4 adt-CD45RO\n\n\nVisualizing antibody signal\nOverlay antibody signal on UMAPs\n\n\n# Set active.assay to ADT\nfilt_so@active.assay <- \"ADT\"\n\n# Overlay antibody signal on gene expression UMAP\nfeats <- c(\n  \"adt-CD4\", \"CD4\",\n  \"adt-CD8\", \"CD8A\"\n)\n\nfilt_so %>%\n  FeaturePlot(\n    reduction = \"umap\",\n    features  = feats\n  )\n\n\n\n# Overlay antibody signal on antibody UMAP\nfilt_so %>%\n  FeaturePlot(\n    reduction = \"adt_umap\",\n    features  = feats\n  )\n\n\n\n\nRidge plots\n\n\n# Create ridge plot\nfeats <- c(\n  \"adt-CD14\", \"adt-CD45\",\n  \"adt-CD19\", \"adt-CD3\",  \n  \"adt-CD4\",  \"adt-CD8\"\n)\n\nfilt_so %>%\n  RidgePlot(features = feats)\n\n\n\n\nViolin plots\n\n\n# Create violin plots\nfeats <- c(\n  \"adt-CD4\",  \"rna_CD4\",\n  \"adt-CD19\", \"rna_CD19\"\n)\n\nfilt_so %>%\n  VlnPlot(\n    features = feats,\n    ncol     = 2\n  )\n\n\n\n\n\nClassifying cells based on antibody signal\nWe can use 2D scatterplots to derive “gates” to assign cell types in the same manner as done for flow cytometry analysis. Generally the CITE-seq signal has lower dynamic range and signal-to-noise compared to flow cytometry, but the overall patterns seen with flow cytometry are also seen with CITE-seq.\nIdentify CD19+ cells\nCD19 is a marker of B-cells, whereas CD3 is a marker of T-cells. We can compare their expression to classify B-cells.\n\n\n# Plot CD3 and CD19 signal\nCD19_plot <- filt_so %>%\n  FeatureScatter(\"adt-CD3\", \"adt-CD19\")\n\nCD19_plot\n\n\n\n\n\n\n# Identify CD19+ cells using antibody signal\nCD19_cells <- filt_so %>%\n  subset(`adt-CD19` > 2.5 & `adt-CD3` < 1) %>%\n  Cells()\n\nhead(CD19_cells)\n\n\n#> [1] \"AAACCTGAGCTACCGC\" \"AAAGCAATCTGTCCGT\" \"AACACGTGTCGCTTCT\"\n#> [4] \"AACCATGGTCTGGTCG\" \"AACGTTGTCAATCACG\" \"AACTTTCCAGCCTTGG\"\n\n# Set cell identities\nlabeled_so <- filt_so %>%\n  SetIdent(value = \"Other\") %>%\n  SetIdent(value = \"CD19+\", cells = CD19_cells)\n\n# Add cell identities to meta.data\nlabeled_so$CD19_class <- Idents(labeled_so)\n\n# Label UMAP with new cell identities\nlabeled_so %>%\n  DimPlot(reduction = \"adt_umap\")\n\n\n\n\nLabel cells using CellSelector()\n\n\n# Identify CD19+ cells using antibody signal\nlabeled_so <- filt_so %>%\n  SetIdent(value = \"Other\")\n\nlabeled_so <- CellSelector(\n  plot   = CD19_plot,\n  object = labeled_so,\n  ident  = \"B cells\"\n)\n\n# Label UMAP with new cell identities\nlabeled_so %>%\n  DimPlot(reduction = \"adt_umap\")\n\n\n\nIdentify CD4+ and CD8+ cells\nIdentify CD4+ and CD8+ cells using one of the methods shown above.\n\n\n\n\n\n# Write your answer here\n#\n#\n#\n#\n#\n#\n#\n#\n#\n#\n\n\n\n\nExamine CITE-seq derived cell labels on gene expression umap\n\n\nlabeled_so %>%\n  DimPlot( \n    reduction = \"umap\",\n    group.by  = \"cell_label\"\n  )\n\n\n\n\n\nCombining CITE-seq and gene expression data\nThe authors of Seurat have implemented a new algorithm for combined data from different types of assays (e.g. antibody data and RNA data), described here and presented in a vignette.\nThe basic idea is that we want to cluster and visualize the data using both the RNA and antibody data. How to do this?\nWe could literally just merge the two datasets together then run them through Seurat. This will however end up downweighting the contribution of the antibody data because there are so few antibodies(~8) compared to RNA features (~10,000)\nSeurat has implemented a “Weighted Nearest Neighbor” approach that will combine the nearest neighbor graphs from the RNA data with the antibody data. The algorithm will calculate relative weights for the RNA or the Protein data for each cell and use these new weights to constuct a shared graph. The related weights are calculated based on the relative information content of neighboring cells in each modalitly. So if the data from one modality provides more information, it is weighted higher.\n\n\n# Need to run PCA on the antibody data\nlabeled_so <- labeled_so %>%\n  RunPCA( \n    assay          = \"ADT\", \n    features       = rownames(labeled_so[[\"ADT\"]]),\n    reduction.name = \"adt_pca\"\n  )\n\nlabeled_so <- labeled_so %>%\n  FindMultiModalNeighbors(\n    reduction.list       = list(\"pca\", \"adt_pca\"),\n    dims.list            = list(1:20, 1:6),\n    modality.weight.name = \"RNA.weight\"\n  )\n\nlabeled_so <- labeled_so %>%\n  RunUMAP(\n    nn.name        = \"weighted.nn\", \n    reduction.name = \"wnn.umap\", \n    reduction.key  = \"wnnUMAP_\"\n  )\n\n\n\n\n\nrna_umap  <- DimPlot(labeled_so, reduction = \"umap\")\nadt_umap  <- DimPlot(labeled_so, reduction = \"adt_umap\")\nboth_umap <- DimPlot(labeled_so, reduction = \"wnn.umap\")\n\nplot_grid(\n  rna_umap, adt_umap, both_umap,\n  labels = c(\"RNA\", \"ADT\", \"Both\"),\n  ncol   = 3\n)\n\n\n\n\n\nViewing results with the UCSC Cell Browser\nThe UCSC Cell Browser allows you to easily explore and share single-cell data. With the Cell Browser you can:\nView t-SNE or UMAP projections\nColor cells by metadata and gene expression\nView cluster marker genes\nRename clusters and add custom annotations to selected sets of cells\nUCSC hosts a large collection of cellbrowsers for various single cell datasets.\nMerge gene expression and antibody matrices\nWe won’t be generating these browsers in the class, however below is an example of how to build a browser. The first step is to combine the gene expression and antibody data into a single matrix.\n\n\n# Combine RNA and ADT matrices\nmerged_so   <- labeled_so\nRNA_data    <- merged_so[[\"RNA\"]]@data\nADT_data    <- merged_so[[\"ADT\"]]@data\nmerged_data <- rbind(RNA_data, ADT_data)\n\n# Add merged matrix to Seurat object\nmerged_so[[\"RNA\"]]@data <- merged_data\n\n# Set active assay\nmerged_so@active.assay <- \"RNA\"\n\n\n\nCreate Cell Browser files\nTo create the files needed for the session, we can use the make_cellbrowser function from the scbp package written by Kent Riemondy. This function extracts the required data from our Seurat object and generates configuration files needed to build the session. To include both the gene expression and antibody UMAPs, we generate separate sets of files for each.\n\n\n# Create Cell Browser directories for gene expression data\ndir.create(\n  path      = \"cellbrowser\",\n  recursive = TRUE\n)\n\n# meta.data fields to include in browser\nfeats <- c(\n  \"Sample\"      = \"sample\",\n  \"clusters\"    = \"RNA_clusters\",\n  \"ADT cluster\" = \"ADT_clusters\",\n  \"Cell label\"  = \"cell_label\",\n  \n  \"RNA UMI count\"     = \"nCount_RNA\",\n  \"Gene count\"        = \"nFeature_RNA\",\n  \"Percent mito UMIs\" = \"percent_mito\",\n  \"ADT UMI count\"     = \"nCount_ADT\",\n  \"Antibody count\"    = \"nFeature_ADT\",\n  \"HTO UMI count\"     = \"nCount_HTO\",\n  \"HTO count\"         = \"nFeature_HTO\"\n)\n\n# Create Cell Browser files for gene expression data\nmerged_so %>%\n  make_cellbrowser(\n    outdir      = \"cellbrowser\",\n    column_list = feats,\n    embeddings  = \"umap\",\n    project     = \"RNA\"\n  )\n\n\n\n\n\n# Create Cell Browser files for antibody data\nmerged_so %>%\n  make_cellbrowser(\n    outdir      = \"cellbrowser\",\n    column_list = feats,\n    embeddings  = \"adt_umap\",\n    project     = \"ADT\"\n  )\n\n\n\nBuild Cell Browser session\nTo build the cell browser session, install cbBuild. This tool will build the session using the configuration files generated in the previous step.\n\nmkdir -p cellbrowser/browser\n\ncbBuild \\\n  -i cellbrowser/RNA/cellbrowser.conf \\\n  -i cellbrowser/ADT/cellbrowser.conf \\\n  -o cellbrowser/browser \\\n  -p 8888\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-10-27T19:16:53-06:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-09-14-tba/",
    "title": "TBA",
    "description": "Content to be added prior to course. See previous workshops for content from earlier workshops.",
    "author": [],
    "date": "2021-09-14",
    "categories": [],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2021-10-13T15:14:51-06:00",
    "input_file": {}
  }
]
