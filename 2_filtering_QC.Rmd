---
title: <b style="font-size:45px;">Data Filtering and Quality Control</b>
author: "Ryan Sheridan"
date: "August 13<sup>th</sup>, 2019"
output:
  html_document:
    toc: true
    toc_depth: 1
---

```{r "Load packages", include = FALSE}

library(Seurat)
library(tidyverse)

knitr::opts_chunk$set(
  message   = FALSE,
  warning   = FALSE,
  comment   = "#>",
  fig.align = "center"
)

```

<br>

<br>

# **Creating a Seurat object**

When analyzing scRNA-seq data in R, counts are stored as a `sparse.matrix` due to the high percentage of zeros. In a sparse matrix zeros are removed and only non-zero values are stored, which saves memory and speeds up operations.

The `Read10X` function can be used with the output directory generated by Cell Ranger to load the data as a sparse matrix. However, our data is saved as a comma-separated matrix, which can be loaded as a data.frame and then converted to a sparse matrix.
```{r "Load data"}

# Import matrix of counts
data_url = "https://scrnaseq-workshop.s3-us-west-2.amazonaws.com"

pbmc_mtx <- file.path(data_url, "PBMC_cDNA.csv.gz") %>%
  read_csv() %>%
  column_to_rownames("X1") %>%
  as.sparse()

pbmc_mtx[1:10, 1:10]

# Calculate fraction of zeros
n_zeros <- pbmc_mtx[pbmc_mtx == 0] %>%
  length()

n_zeros / length(pbmc_mtx)

# Create Seurat object using gene expression data
sobj <- pbmc_mtx %>%
  CreateSeuratObject(
    min.cells   = 5,      # Remove genes that are detected in <5 cells
    project     = "PBMC",
    names.field = 2,
    names.delim = "-"
  )

```

<br>

<br>

# **Interacting with the Seurat Object**

## Handling multiple assays

With Seurat v3.0, the Seurat object has been modified to allow users to easily store multiple scRNA-seq assays in the same object. Users can easliy switch between different assays and select which assay to use with different Seurat functions.
```{r "Handling multiple assays"}

# Assays are stored in the "assays" slot
sobj@assays

# The Seurat object stores the current default assay
sobj@active.assay

DefaultAssay(sobj)

```

## Retrieving raw and normalized counts
```{r "Retrieving raw and normalized counts"}

# Raw counts
sobj@assays$RNA@counts[1:5, 1:10]

sobj %>%
  GetAssayData(slot = "counts") %>%
  .[1:5, 1:10]

# Normalized counts
# This matrix is the same as counts since we haven't normalized the data yet
sobj@assays$RNA@data[1:5, 1:10]

sobj %>%
  GetAssayData(slot = "data") %>%
  .[1:5, 1:10]

```

## Retrieving cell and features names
```{r "Retrieving cell names"}

# Get cell names
sobj@assays$RNA@counts %>%
  colnames() %>%
  head(20)

sobj %>%
  Cells() %>%
  head(20)

sobj %>%
  colnames() %>%
  head(20)

# Get feature names
sobj@assays$RNA@counts %>%
  rownames() %>%
  head(20)

sobj %>%
  rownames() %>%
  head(20)

# Get cell (colums) and feature (rows) counts
ncol(sobj)
nrow(sobj)

```

## Modifying project meta.data
```{r "Accessing meta.data"}

# The meta.data table contains stats for each cell
sobj@meta.data %>%
  head()

sobj[["nCount_RNA"]] %>%
  head()

sobj %>%
  FetchData(vars = "nCount_RNA") %>%
  head()

# FetchData can also be used to retrieve other data from the Seurat object
sobj %>%
  FetchData(
    vars = "CD8A", 
    slot = "counts"
  ) %>%
  head()

# Modify orig.ident to include cell type
sobj@meta.data <- sobj@meta.data %>%
  rownames_to_column("cell_bc") %>%
  mutate(orig.ident = str_c("pbmc-", orig.ident)) %>%
  column_to_rownames("cell_bc")
  
sobj@meta.data %>%
  head()

```

## Setting cell identities
```{r "Setting cell identities"}

# By default the cell identity is set to the project name
sobj@active.ident %>%
  head()

sobj %>%
  Idents() %>%
  head()

# Set cell identities
Idents(sobj) <- sobj[["orig.ident"]]

sobj %>%
  Idents() %>%
  head()

# Rename cell identities
sobj <- sobj %>%
  RenameIdents(
    "pbmc-1" = "control",
    "pbmc-2" = "treated"
  )

sobj %>%
  Idents() %>%
  head()

# Add cell identities to the meta.data table
sobj[["orig.ident"]] <- Idents(sobj)

sobj <- sobj %>%
  AddMetaData(
    metadata = Idents(sobj),
    col.name = "orig.ident"
  )

sobj@meta.data %>%
  head()

```

## Subsetting the Seurat object
```{r "Subsetting the Seurat object"}

# Subset based on gene expression
sobj %>%
  subset(CD8A > 1) %>%
  ncol()

# Subset based on cell identity
sobj %>%
  subset(idents = "control") %>%
  ncol()

# Subset with vector of features
sobj %>%
  subset(features = c("CD4", "CD8A")) %>%
  rownames()

# Subset with vector of cell barcodes
sobj %>%
  subset(cells = c("AAACGCTGACCAGT-1", "AAATCATGACCACA-1", "TTTCGAACACCTGA-2")) %>%
  colnames()

# Subset using multiple criteria
sobj %>%
  subset(CD8A > 1, idents = "control") %>%
  ncol()

# Subset based on meta.data columns
sobj %>%
  subset(nFeature_RNA > 250)

```

## Other data slots
```{r "Other data slots"}

sobj@reductions
sobj@graphs

```

<br>

<br>

# **Assessing quality**

Metrics that are commonly used to assess cell quality include:

* Number of counts per cell barcode
* Number of genes per barcode
* The percentage of counts from mitochondrial genes per barcode

## Calculate the percentage of mitochondrial reads for each cell

The `PercentageFeatureSet` function can be used to calculate the percentage of reads that align to a set of features (genes). This information is automatically added to the meta.data table.
```{r "Calculate percent mito"}

# Calculate percentage of mitochondrial reads for each cell
sobj <- sobj %>%
  PercentageFeatureSet(
    pattern  = "^MT-", 
    col.name = "percent_mito"
  )

sobj@meta.data %>%
  head()

```

## EXERCISE: Create violin/box plots comparing cell metrics
```{r}

# Create violin/boxplots comparing nCount, nFeature, and percent_mito for each sample

# sobj@meta.data %>%



```

## ANSWER
```{r echo = FALSE, fig.width = 8, fig.height = 6}

# Using Seurat functions
# sobj %>%
#   VlnPlot(
#     features = c("nCount_RNA", "nFeature_RNA", "percent_mito"),
#     ncol     = 3,
#     pt.size  = 0.25
#   )

# Using ggplot2
sobj@meta.data %>%
  gather(key, value, -orig.ident) %>%
  ggplot(aes(orig.ident, value, color = orig.ident)) +
  geom_violin(size = 2) +
  geom_jitter(size = 0.5, color = "black", alpha = 0.4) +
  facet_wrap(~key, scales = "free") +
  theme(legend.position = "none") +
  cowplot::theme_cowplot()

```

## EXERCISE: Create scatter plots comparing cell metrics
```{r}

# Create a scatter plot comparing nCount and percent_mito

# sobj@meta.data %>%



# Create a scatter plot comparing nCount and nFeature

# sobj@meta.data %>%



```

## ANSWER
```{r echo = FALSE, fig.width = 8, fig.height = 8}

# Using Seurat functions
# scatter_1 <- sobj %>%
#   FeatureScatter(
#     feature1 = "nCount_RNA", 
#     feature2 = "percent_mito"
#   )

# scatter_2 <- sobj %>%
#   FeatureScatter(
#     feature1 = "nCount_RNA",
#     feature2 = "nFeature_RNA"
#   )

# Using ggplot2
p_1 <- sobj@meta.data %>%
  ggplot(aes(nCount_RNA, percent_mito, color = orig.ident)) +
  geom_point() +
  cowplot::theme_cowplot()

p_2 <- sobj@meta.data %>%
  ggplot(aes(nCount_RNA, nFeature_RNA, color = orig.ident)) +
  geom_point() +
  cowplot::theme_cowplot()

CombinePlots(
  plots = list(p_1, p_2),
  ncol  = 1 
)

```

<br>

<br>

# **Filtering cells**

```{r "Filtering cells"}

# Filter cells based on number of genes and percent mito UMIs
sobj <- sobj %>%
  subset(
    nFeature_RNA > 250 &   # Remove cells with < 250 detected genes
    nFeature_RNA < 2500 &  # Remove cells with > 2500 detected genes (could be doublets)
    percent_mito < 10      # Remove cells with >15% mitochondrial reads
  )

# Add filtering cutoffs on original scatter plots
p_1 <- p_1 +
  geom_hline(yintercept = 10, linetype = 2)

p_2 <- p_2 +
  geom_hline(yintercept = c(250, 2500), linetype = 2)

CombinePlots(
  plots = list(p_1, p_2), 
  nrow  = 2
)

# How many cells were removed?
ncol(sobj)

```

## Saving the Seurat object
```{r "Saving Seurat object", eval = FALSE}

dir.create("data", showWarnings = FALSE)

sobj %>%
  write_rds("data/filtered_sobj.rds")

```



